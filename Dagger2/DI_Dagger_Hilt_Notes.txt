DI - Dependency Injection : One Class Depend on Other class
There are two major ways to do dependency injection
    1) Constructor Injection.   : You pass the dependencies of a class to its constructor
    2) Field Injection (or Setter Injection)  : When Dependency class initilised from current class object
       Ex 
            class Car {
                lateinit var engine: Engine
                fun start() { engine.start() }
            }
            fun main(args: Array) {
                val car = Car()
                car.engine = Engine()
                car.start()
            }
    
Dpendency injection by hand, or manual dependency injection
    - You created, provided, and managed the dependencies of the different classes yourself, without relying on a library.
    * Drawback : 
            - For big apps, taking all the dependencies and connecting them correctly can require a large amount of boilerplate code.
            - In a multi-layered architecture, if object create for a top layer, you have create/provide dependencies of the layers below it.
     
     - These Drawbacks solved by automating the process of creating and providing dependencies by two ways
     
            - Reflection-based solutions : which connect dependencies at runtime.
            - Static solutions : which generate the code to connect dependencies at compile time.


Dagger : 
    - It is a popular dependency injection library for Java, Kotlin, and Android that is maintained by Google.
    - It provides fully static and compile-time dependencies.

Dagger = DAG = Directed Acyclic Graph 

//Dagger Dependency
implementation 'com.google.dagger:dagger:2.28.3'
annotationProcessor 'com.google.dagger:dagger-compiler:2.28'


Note: Whenever you feel perticular class is creating without change at all time just create singleton for it and pass its reference


_____________________________________________________________________________________________________________________________________________________________________

Method -1 (By Injecting constructor)
====================================

class Male @Inject constructor()
class Female @Inject constructor()

class Human @Inject constructor(private var male: Male, private var female: Female) {
    fun doWork() { Log.d("AXE", "Human Class Working...") }
}

@Component
interface HumanComponent {
    fun getWorkingStatus() : Human
}

InMainActivity
    val component : HumanComponent? = DaggerHumanComponent.create()
    val status : Human? = component?.getWorkingStatus()
    status?.doWork()
    
____________________________________________________________________________________________________________________________________________________________________

********************************************************************************************************************************************************************
********************************************************************************************************************************************************************

Hilt : 
    - It is Jetpack's recommended library for dependency injection in Android
    - Hilt defines a standard way to do DI in your application by providing containers for every Android class in your project and managing their lifecycles automatically for you.
    - Use Hilt for dependency injection on Android. 
    - Hilt is built on top of Dagger and it provides a standard way to incorporate Dagger dependency injection into an Android application.


    - @Inject     : lets Dagger know how to create instances of object
    - @Component  : tells Dagger to generate a container with all the dependencies required to satisfy the types, 
                    it contains a graph that consists objects that Dagger knows how to provide and their respective
                    Inside the @Component interface, you can define functions that return instances of the classes you need





